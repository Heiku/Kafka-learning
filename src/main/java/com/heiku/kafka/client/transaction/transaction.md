
### 事务

#### 消息传输保障

消息传输保障有 3 个级别，如下：

1. at most once: 最多一次，消息可能会丢失，但绝对不会重复传输
2. at least once: 最少一次，消息绝不会丢失，但可能会重复传输
3. exactly once: 恰好一次，每条消息肯定会被传输一次且仅传输一次

* 生产者

生产者向 Kafka 发送消息时，一旦消息被成功提交到日志文件，由于 __多副本机制的存在，消息不会丢失__。但如果生产者发送消息
到 Kafka 之后，遇到网络问题而造成了通信中断，那么生成者 producer 无法判断该消息是否已经提交。虽然 Kafka 无法确定网络
故障期间发生了什么，但生产者可以进行多次重试确保消息已经写入 Kafka，这个重试的过程可能会造成消息的 __重复写入__，
所以这里 Kafka 提供的消息传输保障为 at least。

* 消费者

消费者处理消息和提交消费位移的顺序在很大程度上决定了消费者提供哪一种消息传输保障。

如果消费者在拉取完消息之后，应用逻辑先处理消息后提交消费位移，那么消息处理完之后在消费位移提交之前发生宕机，待它重新上线
之后，会从上一次位移提交的位置拉取，这样就出现了重复消费。因为有部分消息已经处理过了只是还没来得及提交消费位移，
此时对应 at least once。

如果消费者在拉完消息之后，应用逻辑先提交消费位移后进行消息处理，那么在位移提交之后且消息处理完成之前消费者宕机了，
待它重新上线之后，会从已经提交的唯一处开始重新消费，但之前尚有部分消息未进行消费，如此就会发生消息丢失，对应 at most once

#### 幂等

幂等：对接口的多次调用所产生的结果和调用一次是一致的（避免了生产者重复写入的问题）

幂等功能的开启需要修改生成者客户端参数 `enable.idempotence = true`（默认为false）

* 实现

Kafka 引入了 producer_id（PID）和 序列号（sequence_number）的概念，分别对应 v2 日志格式中 RecordBatch 的 `producer_id` 和 
`first_sequence` 这两个字段。每个生产者实例在初始化的时候都会被分配一个 PID，对于每个 PID 消息发送到每一个分区都有对应的
序列号，序列号从 0 开始递增。生产者每个送一条消息，就会将 <PID, 分区> 对应的序列号的值 + 1。

broker 在内存中为每一对 <PID, 分区>维护了一个序列号。只有当消息的序列号（SN_new） = broker 中的序列号（SN_old）+ 1 时，
broker 才会接收它。

    * 如果 SN_new < SN_old + 1，说明消息被重复写入，可以直接丢弃  
    * 如果 SN_new > SN_old + 1，说明消息可能存在丢失，生产者会抛出将对应的 OutOfOrderSequenceException
    
